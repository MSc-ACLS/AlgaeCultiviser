import {
  B,
  C2 as C,
  Fr,
  H,
  H2,
  Ht,
  I,
  It,
  Jt,
  Kt,
  O,
  Ot,
  Qt,
  Rn,
  Sn,
  St,
  Ur,
  W,
  Wn,
  animated,
  dn,
  gn,
  j,
  jn,
  k,
  linear,
  pr,
  require_Stack,
  require_Symbol,
  require_arrayFilter,
  require_arrayMap,
  require_arrayPush,
  require_assignValue,
  require_baseEach,
  require_baseGet,
  require_baseGetAllKeys,
  require_baseGetTag,
  require_baseIteratee,
  require_baseUnary,
  require_castPath,
  require_cloneArrayBuffer,
  require_cloneBuffer,
  require_cloneTypedArray,
  require_copyArray,
  require_copyObject,
  require_flatRest,
  require_get,
  require_getAllKeys,
  require_getPrototype,
  require_getSymbols,
  require_getTag,
  require_initCloneObject,
  require_isArray,
  require_isBuffer,
  require_isObject,
  require_isObjectLike,
  require_isPlainObject,
  require_isString,
  require_keys,
  require_keysIn,
  require_last,
  require_nodeUtil,
  require_stubArray,
  require_toKey,
  useSpring,
  useTransition,
  w,
  wt,
  z,
  z2,
  zt
} from "./chunk-Q52FDZIS.js";
import "./chunk-OX56QJAV.js";
import "./chunk-KMN5OX7C.js";
import {
  require_jsx_runtime
} from "./chunk-5AS4NL4J.js";
import {
  require_react
} from "./chunk-RUPNRBO7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module.exports = baseFilter;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = filter;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol = require_Symbol();
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "node_modules/lodash/_parent.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }
    module.exports = parent;
  }
});

// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "node_modules/lodash/_baseUnset.js"(exports, module) {
    var castPath = require_castPath();
    var last = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }
    module.exports = baseUnset;
  }
});

// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "node_modules/lodash/_customOmitClone.js"(exports, module) {
    var isPlainObject = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject(value) ? void 0 : value;
    }
    module.exports = customOmitClone;
  }
});

// node_modules/lodash/omit.js
var require_omit = __commonJS({
  "node_modules/lodash/omit.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    module.exports = omit;
  }
});

// node_modules/@nivo/scatterplot/dist/nivo-scatterplot.es.js
var import_react2 = __toESM(require_react());

// node_modules/@nivo/annotations/dist/nivo-annotations.es.js
var import_react = __toESM(require_react());
var import_filter = __toESM(require_filter());
var import_isNumber = __toESM(require_isNumber());
var import_omit = __toESM(require_omit());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function g() {
  return g = Object.assign ? Object.assign.bind() : function(t3) {
    for (var n3 = 1; n3 < arguments.length; n3++) {
      var i3 = arguments[n3];
      for (var o3 in i3) Object.prototype.hasOwnProperty.call(i3, o3) && (t3[o3] = i3[o3]);
    }
    return t3;
  }, g.apply(this, arguments);
}
var k2 = { dotSize: 4, noteWidth: 120, noteTextOffset: 8, animate: true };
var W2 = function(n3) {
  var i3 = typeof n3;
  return (0, import_react.isValidElement)(n3) || "string" === i3 || "function" === i3 || "object" === i3;
};
var v = function(t3) {
  var n3 = typeof t3;
  return "string" === n3 || "function" === n3;
};
var b = function(t3) {
  return "circle" === t3.type;
};
var w2 = function(t3) {
  return "dot" === t3.type;
};
var z3 = function(t3) {
  return "rect" === t3.type;
};
var P = function(t3) {
  var n3 = t3.data, i3 = t3.annotations, e3 = t3.getPosition, r2 = t3.getDimensions;
  return i3.reduce(function(t4, i4) {
    var s = i4.offset || 0;
    return [].concat(t4, (0, import_filter.default)(n3, i4.match).map(function(t5) {
      var n4 = e3(t5), o3 = r2(t5);
      return (b(i4) || z3(i4)) && (o3.size = o3.size + 2 * s, o3.width = o3.width + 2 * s, o3.height = o3.height + 2 * s), g({}, (0, import_omit.default)(i4, ["match", "offset"]), n4, o3, { size: i4.size || o3.size, datum: t5 });
    }));
  }, []);
};
var C2 = function(t3, n3, i3, o3) {
  var e3 = Math.atan2(o3 - n3, i3 - t3);
  return Qt(Kt(e3));
};
var O2 = function(t3) {
  var n3, i3, o3 = t3.x, a3 = t3.y, r2 = t3.noteX, s = t3.noteY, h = t3.noteWidth, d2 = void 0 === h ? k2.noteWidth : h, c = t3.noteTextOffset, f = void 0 === c ? k2.noteTextOffset : c;
  if ((0, import_isNumber.default)(r2)) n3 = o3 + r2;
  else {
    if (void 0 === r2.abs) throw new Error("noteX should be either a number or an object containing an 'abs' property");
    n3 = r2.abs;
  }
  if ((0, import_isNumber.default)(s)) i3 = a3 + s;
  else {
    if (void 0 === s.abs) throw new Error("noteY should be either a number or an object containing an 'abs' property");
    i3 = s.abs;
  }
  var y = o3, x2 = a3, m2 = C2(o3, a3, n3, i3);
  if (b(t3)) {
    var p2 = Jt(Ht(m2), t3.size / 2);
    y += p2.x, x2 += p2.y;
  }
  if (z3(t3)) {
    var g2 = Math.round((m2 + 90) / 45) % 8;
    0 === g2 && (x2 -= t3.height / 2), 1 === g2 && (y += t3.width / 2, x2 -= t3.height / 2), 2 === g2 && (y += t3.width / 2), 3 === g2 && (y += t3.width / 2, x2 += t3.height / 2), 4 === g2 && (x2 += t3.height / 2), 5 === g2 && (y -= t3.width / 2, x2 += t3.height / 2), 6 === g2 && (y -= t3.width / 2), 7 === g2 && (y -= t3.width / 2, x2 -= t3.height / 2);
  }
  var W4 = n3, v2 = n3;
  return (m2 + 90) % 360 > 180 ? (W4 -= d2, v2 -= d2) : v2 += d2, { points: [[y, x2], [n3, i3], [v2, i3]], text: [W4, i3 - f], angle: m2 + 90 };
};
var S = function(t3) {
  var i3 = t3.data, o3 = t3.annotations, e3 = t3.getPosition, a3 = t3.getDimensions;
  return (0, import_react.useMemo)(function() {
    return P({ data: i3, annotations: o3, getPosition: e3, getDimensions: a3 });
  }, [i3, o3, e3, a3]);
};
var M = function(t3) {
  return (0, import_react.useMemo)(function() {
    return O2(t3);
  }, [t3]);
};
var T = function(t3) {
  var n3 = t3.datum, o3 = t3.x, e3 = t3.y, r2 = t3.note, s = zt(), l = Ur(), u = l.animate, c = l.config, k3 = useSpring({ x: o3, y: e3, config: c, immediate: !u });
  return "function" == typeof r2 ? (0, import_react.createElement)(r2, { x: o3, y: e3, datum: n3 }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [s.annotations.text.outlineWidth > 0 && (0, import_jsx_runtime.jsx)(animated.text, { x: k3.x, y: k3.y, style: g({}, s.annotations.text, { strokeLinejoin: "round", strokeWidth: 2 * s.annotations.text.outlineWidth, stroke: s.annotations.text.outlineColor }), children: r2 }), (0, import_jsx_runtime.jsx)(animated.text, { x: k3.x, y: k3.y, style: (0, import_omit.default)(s.annotations.text, ["outlineWidth", "outlineColor"]), children: r2 })] });
};
var E = function(t3) {
  var i3 = t3.points, o3 = t3.isOutline, e3 = void 0 !== o3 && o3, a3 = zt(), r2 = (0, import_react.useMemo)(function() {
    var t4 = i3[0];
    return i3.slice(1).reduce(function(t5, n3) {
      return t5 + " L" + n3[0] + "," + n3[1];
    }, "M" + t4[0] + "," + t4[1]);
  }, [i3]), s = Fr(r2);
  if (e3 && a3.annotations.link.outlineWidth <= 0) return null;
  var l = g({}, a3.annotations.link);
  return e3 && (l.strokeLinecap = "square", l.strokeWidth = a3.annotations.link.strokeWidth + 2 * a3.annotations.link.outlineWidth, l.stroke = a3.annotations.link.outlineColor, l.opacity = a3.annotations.link.outlineOpacity), (0, import_jsx_runtime.jsx)(animated.path, { fill: "none", d: s, style: l });
};
var I2 = function(t3) {
  var n3 = t3.x, i3 = t3.y, o3 = t3.size, e3 = zt(), a3 = Ur(), r2 = a3.animate, s = a3.config, l = useSpring({ x: n3, y: i3, radius: o3 / 2, config: s, immediate: !r2 });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [e3.annotations.outline.outlineWidth > 0 && (0, import_jsx_runtime.jsx)(animated.circle, { cx: l.x, cy: l.y, r: l.radius, style: g({}, e3.annotations.outline, { fill: "none", strokeWidth: e3.annotations.outline.strokeWidth + 2 * e3.annotations.outline.outlineWidth, stroke: e3.annotations.outline.outlineColor, opacity: e3.annotations.outline.outlineOpacity }) }), (0, import_jsx_runtime.jsx)(animated.circle, { cx: l.x, cy: l.y, r: l.radius, style: e3.annotations.outline })] });
};
var D = function(t3) {
  var n3 = t3.x, i3 = t3.y, o3 = t3.size, e3 = void 0 === o3 ? k2.dotSize : o3, a3 = zt(), r2 = Ur(), s = r2.animate, l = r2.config, u = useSpring({ x: n3, y: i3, radius: e3 / 2, config: l, immediate: !s });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [a3.annotations.outline.outlineWidth > 0 && (0, import_jsx_runtime.jsx)(animated.circle, { cx: u.x, cy: u.y, r: u.radius, style: g({}, a3.annotations.outline, { fill: "none", strokeWidth: 2 * a3.annotations.outline.outlineWidth, stroke: a3.annotations.outline.outlineColor, opacity: a3.annotations.outline.outlineOpacity }) }), (0, import_jsx_runtime.jsx)(animated.circle, { cx: u.x, cy: u.y, r: u.radius, style: a3.annotations.symbol })] });
};
var L = function(t3) {
  var n3 = t3.x, i3 = t3.y, o3 = t3.width, e3 = t3.height, a3 = t3.borderRadius, r2 = void 0 === a3 ? 6 : a3, s = zt(), l = Ur(), u = l.animate, c = l.config, k3 = useSpring({ x: n3 - o3 / 2, y: i3 - e3 / 2, width: o3, height: e3, config: c, immediate: !u });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [s.annotations.outline.outlineWidth > 0 && (0, import_jsx_runtime.jsx)(animated.rect, { x: k3.x, y: k3.y, rx: r2, ry: r2, width: k3.width, height: k3.height, style: g({}, s.annotations.outline, { fill: "none", strokeWidth: s.annotations.outline.strokeWidth + 2 * s.annotations.outline.outlineWidth, stroke: s.annotations.outline.outlineColor, opacity: s.annotations.outline.outlineOpacity }) }), (0, import_jsx_runtime.jsx)(animated.rect, { x: k3.x, y: k3.y, rx: r2, ry: r2, width: k3.width, height: k3.height, style: s.annotations.outline })] });
};
var R = function(t3) {
  var n3 = t3.datum, i3 = t3.x, o3 = t3.y, e3 = t3.note, a3 = M(t3);
  if (!W2(e3)) throw new Error("note should be a valid react element");
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(E, { points: a3.points, isOutline: true }), b(t3) && (0, import_jsx_runtime.jsx)(I2, { x: i3, y: o3, size: t3.size }), w2(t3) && (0, import_jsx_runtime.jsx)(D, { x: i3, y: o3, size: t3.size }), z3(t3) && (0, import_jsx_runtime.jsx)(L, { x: i3, y: o3, width: t3.width, height: t3.height, borderRadius: t3.borderRadius }), (0, import_jsx_runtime.jsx)(E, { points: a3.points }), (0, import_jsx_runtime.jsx)(T, { datum: n3, x: a3.text[0], y: a3.text[1], note: e3 })] });
};
var q = function(t3, n3) {
  n3.forEach(function(n4, i3) {
    var o3 = n4[0], e3 = n4[1];
    0 === i3 ? t3.moveTo(o3, e3) : t3.lineTo(o3, e3);
  });
};
var J = function(t3, n3) {
  var i3 = n3.annotations, o3 = n3.theme;
  0 !== i3.length && (t3.save(), i3.forEach(function(n4) {
    if (!v(n4.note)) throw new Error("note is invalid for canvas implementation");
    o3.annotations.link.outlineWidth > 0 && (t3.lineCap = "square", t3.strokeStyle = o3.annotations.link.outlineColor, t3.lineWidth = o3.annotations.link.strokeWidth + 2 * o3.annotations.link.outlineWidth, t3.beginPath(), q(t3, n4.computed.points), t3.stroke(), t3.lineCap = "butt"), b(n4) && o3.annotations.outline.outlineWidth > 0 && (t3.strokeStyle = o3.annotations.outline.outlineColor, t3.lineWidth = o3.annotations.outline.strokeWidth + 2 * o3.annotations.outline.outlineWidth, t3.beginPath(), t3.arc(n4.x, n4.y, n4.size / 2, 0, 2 * Math.PI), t3.stroke()), w2(n4) && o3.annotations.symbol.outlineWidth > 0 && (t3.strokeStyle = o3.annotations.symbol.outlineColor, t3.lineWidth = 2 * o3.annotations.symbol.outlineWidth, t3.beginPath(), t3.arc(n4.x, n4.y, n4.size / 2, 0, 2 * Math.PI), t3.stroke()), z3(n4) && o3.annotations.outline.outlineWidth > 0 && (t3.strokeStyle = o3.annotations.outline.outlineColor, t3.lineWidth = o3.annotations.outline.strokeWidth + 2 * o3.annotations.outline.outlineWidth, t3.beginPath(), t3.rect(n4.x - n4.width / 2, n4.y - n4.height / 2, n4.width, n4.height), t3.stroke()), t3.strokeStyle = o3.annotations.link.stroke, t3.lineWidth = o3.annotations.link.strokeWidth, t3.beginPath(), q(t3, n4.computed.points), t3.stroke(), b(n4) && (t3.strokeStyle = o3.annotations.outline.stroke, t3.lineWidth = o3.annotations.outline.strokeWidth, t3.beginPath(), t3.arc(n4.x, n4.y, n4.size / 2, 0, 2 * Math.PI), t3.stroke()), w2(n4) && (t3.fillStyle = o3.annotations.symbol.fill, t3.beginPath(), t3.arc(n4.x, n4.y, n4.size / 2, 0, 2 * Math.PI), t3.fill()), z3(n4) && (t3.strokeStyle = o3.annotations.outline.stroke, t3.lineWidth = o3.annotations.outline.strokeWidth, t3.beginPath(), t3.rect(n4.x - n4.width / 2, n4.y - n4.height / 2, n4.width, n4.height), t3.stroke()), "function" == typeof n4.note ? n4.note(t3, { datum: n4.datum, x: n4.computed.text[0], y: n4.computed.text[1], theme: o3 }) : (t3.font = o3.annotations.text.fontSize + "px " + o3.annotations.text.fontFamily, t3.textAlign = "left", t3.textBaseline = "alphabetic", t3.fillStyle = o3.annotations.text.fill, t3.strokeStyle = o3.annotations.text.outlineColor, t3.lineWidth = 2 * o3.annotations.text.outlineWidth, o3.annotations.text.outlineWidth > 0 && (t3.lineJoin = "round", t3.strokeText(n4.note, n4.computed.text[0], n4.computed.text[1]), t3.lineJoin = "miter"), t3.fillText(n4.note, n4.computed.text[0], n4.computed.text[1]));
  }), t3.restore());
};

// node_modules/@nivo/scatterplot/dist/nivo-scatterplot.es.js
var import_get = __toESM(require_get());
var import_isString = __toESM(require_isString());
var import_isNumber2 = __toESM(require_isNumber());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function A() {
  return A = Object.assign ? Object.assign.bind() : function(e3) {
    for (var n3 = 1; n3 < arguments.length; n3++) {
      var o3 = arguments[n3];
      for (var i3 in o3) Object.prototype.hasOwnProperty.call(o3, i3) && (e3[i3] = o3[i3]);
    }
    return e3;
  }, A.apply(this, arguments);
}
function U(e3, n3) {
  if (null == e3) return {};
  var o3, i3, t3 = {}, r2 = Object.keys(e3);
  for (i3 = 0; i3 < r2.length; i3++) o3 = r2[i3], n3.indexOf(o3) >= 0 || (t3[o3] = e3[o3]);
  return t3;
}
var q2 = function(e3) {
  if ("function" == typeof e3) return e3;
  if ((0, import_isNumber2.default)(e3)) return function() {
    return e3;
  };
  if (function(e4) {
    return (0, import_isPlainObject.default)(e4);
  }(e3)) {
    if (!(0, import_isString.default)(e3.key)) throw new Error("symbolSize is invalid, key should be a string pointing to the property to use to determine node size");
    if (!Array.isArray(e3.values) || 2 !== e3.values.length) throw new Error("symbolSize is invalid, values spec should be an array containing two values, min and max");
    if (!Array.isArray(e3.sizes) || 2 !== e3.sizes.length) throw new Error("symbolSize is invalid, sizes spec should be an array containing two values, min and max");
    var n3 = linear().domain([e3.values[0], e3.values[1]]).range([e3.sizes[0], e3.sizes[1]]);
    return function(o3) {
      return n3((0, import_get.default)(o3, e3.key));
    };
  }
  throw new Error("nodeSize is invalid, it should be either a function, a number or an object");
};
var J2 = function(n3) {
  var o3, i3 = n3.data, t3 = n3.xScaleSpec, r2 = n3.xFormat, a3 = n3.yScaleSpec, d2 = n3.yFormat, u = n3.width, c = n3.height, h = n3.nodeId, f = n3.nodeSize, v2 = n3.colors, m2 = (0, import_react2.useMemo)(function() {
    return dn(i3, t3, a3, u, c);
  }, [i3, t3, a3, u, c]), g2 = m2.series, p2 = m2.xScale, y = m2.yScale, x2 = Ot(r2), M2 = Ot(d2), S2 = Wn(h), b2 = (0, import_react2.useMemo)(function() {
    return function(e3) {
      var n4 = e3.series, o4 = e3.formatX, i4 = e3.formatY, t4 = e3.getNodeId, r3 = [];
      return n4.forEach(function(e4) {
        e4.data.forEach(function(n5, a4) {
          var d3 = { index: r3.length, serieIndex: a4, serieId: e4.id, x: n5.position.x, xValue: n5.data.x, formattedX: o4(n5.data.x), y: n5.position.y, yValue: n5.data.y, formattedY: i4(n5.data.y), data: n5.data };
          r3.push(A({}, d3, { id: t4(d3) }));
        });
      }), r3;
    }({ series: g2, formatX: x2, formatY: M2, getNodeId: S2 });
  }, [g2, x2, M2, S2]), w3 = (0, import_react2.useMemo)(function() {
    return q2(o3);
  }, [o3 = f]), I3 = pr(v2, "serieId");
  return { xScale: p2, yScale: y, nodes: (0, import_react2.useMemo)(function() {
    return b2.map(function(e3) {
      return A({}, e3, { size: w3(e3), color: I3({ serieId: e3.serieId }) });
    });
  }, [b2, w3, I3]), legendData: (0, import_react2.useMemo)(function() {
    return g2.map(function(e3) {
      return { id: e3.id, label: e3.id, color: I3({ serieId: e3.id }) };
    });
  }, [g2, I3]) };
};
var K = function(e3, n3) {
  return S({ data: e3, annotations: n3, getPosition: function(e4) {
    return { x: e4.x, y: e4.y };
  }, getDimensions: function(e4) {
    return { size: e4.size, width: e4.size, height: e4.size };
  } });
};
var Q = function(e3) {
  return e3 / 2;
};
var Z = { xScale: { type: "linear", min: 0, max: "auto" }, yScale: { type: "linear", min: 0, max: "auto" }, enableGridX: true, enableGridY: true, axisBottom: {}, axisLeft: {}, nodeId: function(e3) {
  return e3.serieId + "." + e3.index;
}, nodeSize: 9, nodeComponent: function(e3) {
  var o3 = e3.node, i3 = e3.style, t3 = e3.blendMode, r2 = e3.isInteractive, a3 = e3.onMouseEnter, d2 = e3.onMouseMove, s = e3.onMouseLeave, l = e3.onClick, u = (0, import_react2.useCallback)(function(e4) {
    return null == a3 ? void 0 : a3(o3, e4);
  }, [o3, a3]), c = (0, import_react2.useCallback)(function(e4) {
    return null == d2 ? void 0 : d2(o3, e4);
  }, [o3, d2]), h = (0, import_react2.useCallback)(function(e4) {
    return null == s ? void 0 : s(o3, e4);
  }, [o3, s]), f = (0, import_react2.useCallback)(function(e4) {
    return null == l ? void 0 : l(o3, e4);
  }, [o3, l]);
  return (0, import_jsx_runtime2.jsx)(animated.circle, { cx: i3.x, cy: i3.y, r: i3.size.to(Q), fill: i3.color, style: { mixBlendMode: t3 }, onMouseEnter: r2 ? u : void 0, onMouseMove: r2 ? c : void 0, onMouseLeave: r2 ? h : void 0, onClick: r2 ? f : void 0 });
}, colors: { scheme: "nivo" }, isInteractive: true, debugMesh: false, tooltip: function(e3) {
  var n3 = e3.node;
  return (0, import_jsx_runtime2.jsx)(w, { id: n3.serieId, value: "x: " + n3.formattedX + ", y: " + n3.formattedY, enableChip: true, color: n3.color });
}, markers: [], legends: [], annotations: [] };
var $ = A({}, Z, { blendMode: "normal", layers: ["grid", "axes", "nodes", "markers", "mesh", "legends", "annotations"], role: "img", useMesh: true, animate: true, motionConfig: "default" });
var _ = A({}, Z, { layers: ["grid", "axes", "nodes", "mesh", "legends", "annotations"], pixelRatio: "undefined" != typeof window && window.devicePixelRatio || 1, renderNode: function(e3, n3) {
  e3.beginPath(), e3.arc(n3.x, n3.y, n3.size / 2, 0, 2 * Math.PI), e3.fillStyle = n3.color, e3.fill();
} });
var ee = function(e3) {
  var n3 = e3.nodes, o3 = e3.annotations, i3 = K(n3, o3);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: i3.map(function(e4, n4) {
    return (0, import_jsx_runtime2.jsx)(R, A({}, e4), n4);
  }) });
};
var ne = function(e3) {
  return e3.id;
};
var oe = function(e3) {
  return { x: e3.x, y: e3.y, size: e3.size, color: e3.color };
};
var ie = function(e3) {
  return { x: e3.x, y: e3.y, size: 0, color: e3.color };
};
var te = function(e3) {
  var i3 = e3.nodes, t3 = e3.nodeComponent, r2 = e3.isInteractive, a3 = e3.onMouseEnter, d2 = e3.onMouseMove, s = e3.onMouseLeave, l = e3.onClick, c = e3.tooltip, h = e3.blendMode, f = Ur(), v2 = f.animate, m2 = f.config, g2 = useTransition(i3, { keys: ne, from: oe, enter: oe, update: oe, leave: ie, config: m2, immediate: !v2 }), p2 = k(), y = p2.showTooltipFromEvent, x2 = p2.hideTooltip, M2 = (0, import_react2.useCallback)(function(e4, n3) {
    y((0, import_react2.createElement)(c, { node: e4 }), n3), null == a3 || a3(e4, n3);
  }, [c, y, a3]), S2 = (0, import_react2.useCallback)(function(e4, n3) {
    y((0, import_react2.createElement)(c, { node: e4 }), n3), null == d2 || d2(e4, n3);
  }, [c, y, d2]), b2 = (0, import_react2.useCallback)(function(e4, n3) {
    x2(), null == s || s(e4, n3);
  }, [x2, s]), w3 = (0, import_react2.useCallback)(function(e4, n3) {
    return null == l ? void 0 : l(e4, n3);
  }, [l]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: g2(function(e4, n3) {
    return (0, import_react2.createElement)(t3, { node: n3, style: e4, blendMode: h, isInteractive: r2, onMouseEnter: r2 ? M2 : void 0, onMouseMove: r2 ? S2 : void 0, onMouseLeave: r2 ? b2 : void 0, onClick: r2 ? w3 : void 0 });
  }) });
};
var re = function(e3) {
  var i3 = e3.nodes, t3 = e3.width, r2 = e3.height, a3 = e3.onMouseEnter, d2 = e3.onMouseMove, s = e3.onMouseLeave, l = e3.onClick, u = e3.tooltip, c = e3.debug, h = k(), f = h.showTooltipFromEvent, v2 = h.hideTooltip, m2 = (0, import_react2.useCallback)(function(e4, n3) {
    f((0, import_react2.createElement)(u, { node: e4 }), n3), a3 && a3(e4, n3);
  }, [f, u, a3]), g2 = (0, import_react2.useCallback)(function(e4, n3) {
    f((0, import_react2.createElement)(u, { node: e4 }), n3), d2 && d2(e4, n3);
  }, [f, u, d2]), p2 = (0, import_react2.useCallback)(function(e4, n3) {
    v2(), s && s(e4, n3);
  }, [v2, s]), y = (0, import_react2.useCallback)(function(e4, n3) {
    l && l(e4, n3);
  }, [l]);
  return (0, import_jsx_runtime2.jsx)(I, { nodes: i3, width: t3, height: r2, onMouseEnter: m2, onMouseMove: g2, onMouseLeave: p2, onClick: y, debug: c });
};
var ae = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var de = function(n3) {
  var t3 = n3.data, r2 = n3.xScale, a3 = void 0 === r2 ? $.xScale : r2, d2 = n3.xFormat, s = n3.yScale, l = void 0 === s ? $.yScale : s, u = n3.yFormat, c = n3.width, m2 = n3.height, g2 = n3.margin, p2 = n3.layers, y = void 0 === p2 ? $.layers : p2, S2 = n3.colors, b2 = void 0 === S2 ? $.colors : S2, I3 = n3.blendMode, k3 = void 0 === I3 ? $.blendMode : I3, z4 = n3.nodeId, E2 = void 0 === z4 ? $.nodeId : z4, C3 = n3.nodeSize, L2 = void 0 === C3 ? $.nodeSize : C3, W4 = n3.nodeComponent, F2 = void 0 === W4 ? $.nodeComponent : W4, X2 = n3.enableGridX, Y2 = void 0 === X2 ? $.enableGridX : X2, B2 = n3.enableGridY, G = void 0 === B2 ? $.enableGridY : B2, H3 = n3.gridXValues, T3 = n3.gridYValues, V = n3.axisTop, j2 = n3.axisRight, O3 = n3.axisBottom, D2 = void 0 === O3 ? $.axisBottom : O3, N = n3.axisLeft, P2 = void 0 === N ? $.axisLeft : N, U2 = n3.annotations, q3 = void 0 === U2 ? $.annotations : U2, K2 = n3.isInteractive, Q2 = void 0 === K2 ? $.isInteractive : K2, Z2 = n3.useMesh, _2 = void 0 === Z2 ? $.useMesh : Z2, ne2 = n3.debugMesh, oe2 = void 0 === ne2 ? $.debugMesh : ne2, ie2 = n3.onMouseEnter, ae2 = n3.onMouseMove, de2 = n3.onMouseLeave, se2 = n3.onClick, le2 = n3.tooltip, ue2 = void 0 === le2 ? $.tooltip : le2, ce2 = n3.markers, he2 = void 0 === ce2 ? $.markers : ce2, fe2 = n3.legends, ve = void 0 === fe2 ? $.legends : fe2, me = n3.role, ge = void 0 === me ? $.role : me, pe = n3.ariaLabel, ye = n3.ariaLabelledBy, xe = n3.ariaDescribedBy, Me = wt(c, m2, g2), Se = Me.margin, be = Me.innerWidth, we = Me.innerHeight, Ie = Me.outerWidth, ke = Me.outerHeight, ze = J2({ data: t3, xScaleSpec: a3, xFormat: d2, yScaleSpec: l, yFormat: u, width: be, height: we, nodeId: E2, nodeSize: L2, colors: b2 }), Ee = ze.xScale, Ce = ze.yScale, Le = ze.nodes, We = ze.legendData, Fe = (0, import_react2.useMemo)(function() {
    return { xScale: Ee, yScale: Ce, nodes: Le, margin: Se, innerWidth: be, innerHeight: we, outerWidth: Ie, outerHeight: ke };
  }, [Ee, Ce, Le, Se, be, we, Ie, ke]), Xe = { grid: null, axes: null, nodes: null, markers: null, mesh: null, annotations: null, legends: null };
  return y.includes("grid") && (Xe.grid = (0, import_jsx_runtime2.jsx)(C, { width: be, height: we, xScale: Y2 ? Ee : null, yScale: G ? Ce : null, xValues: H3, yValues: T3 }, "grid")), y.includes("axes") && (Xe.axes = (0, import_jsx_runtime2.jsx)(B, { xScale: Ee, yScale: Ce, width: be, height: we, top: V, right: j2, bottom: D2, left: P2 }, "axes")), y.includes("nodes") && (Xe.nodes = (0, import_jsx_runtime2.jsx)(te, { nodes: Le, nodeComponent: F2, isInteractive: Q2, tooltip: ue2, blendMode: k3, onMouseEnter: ie2, onMouseMove: ae2, onMouseLeave: de2, onClick: se2 }, "nodes")), y.includes("markers") && (Xe.markers = (0, import_jsx_runtime2.jsx)(Rn, { markers: he2, width: be, height: we, xScale: Ee, yScale: Ce }, "markers")), y.includes("mesh") && Q2 && _2 && (Xe.mesh = (0, import_jsx_runtime2.jsx)(re, { nodes: Le, width: be, height: we, onMouseEnter: ie2, onMouseMove: ae2, onMouseLeave: de2, onClick: se2, tooltip: ue2, debug: oe2 }, "mesh")), y.includes("annotations") && (Xe.annotations = (0, import_jsx_runtime2.jsx)(ee, { nodes: Le, annotations: q3 }, "annotations")), y.includes("legends") && (Xe.legends = ve.map(function(e3, n4) {
    return (0, import_jsx_runtime2.jsx)(O, A({}, e3, { containerWidth: be, containerHeight: we, data: We }), n4);
  })), (0, import_jsx_runtime2.jsx)(gn, { width: Ie, height: ke, margin: Se, role: ge, ariaLabel: pe, ariaLabelledBy: ye, ariaDescribedBy: xe, children: y.map(function(e3, n4) {
    if ("string" == typeof e3 && void 0 !== Xe[e3]) return Xe[e3];
    if ("function" == typeof e3) return (0, import_jsx_runtime2.jsx)(import_react2.Fragment, { children: (0, import_react2.createElement)(e3, Fe) }, n4);
    throw new Error("Unknown layer (" + e3 + ")");
  }) });
};
var se = function(e3) {
  var n3 = e3.isInteractive, o3 = void 0 === n3 ? $.isInteractive : n3, i3 = e3.animate, t3 = void 0 === i3 ? $.animate : i3, r2 = e3.motionConfig, a3 = void 0 === r2 ? $.motionConfig : r2, d2 = e3.theme, s = e3.renderWrapper, l = U(e3, ae);
  return (0, import_jsx_runtime2.jsx)(St, { animate: t3, isInteractive: o3, motionConfig: a3, renderWrapper: s, theme: d2, children: (0, import_jsx_runtime2.jsx)(de, A({ isInteractive: o3 }, l)) });
};
var le = function(e3) {
  return (0, import_jsx_runtime2.jsx)(It, { children: function(n3) {
    var o3 = n3.width, i3 = n3.height;
    return (0, import_jsx_runtime2.jsx)(se, A({ width: o3, height: i3 }, e3));
  } });
};
var ue = ["isInteractive", "renderWrapper", "theme"];
var ce = function(i3) {
  var t3 = i3.data, s = i3.xScale, l = void 0 === s ? _.xScale : s, u = i3.xFormat, c = i3.yScale, f = void 0 === c ? _.yScale : c, v2 = i3.yFormat, m2 = i3.width, x2 = i3.height, M2 = i3.margin, w3 = i3.pixelRatio, k3 = void 0 === w3 ? _.pixelRatio : w3, z4 = i3.layers, E2 = void 0 === z4 ? _.layers : z4, C3 = i3.colors, W4 = void 0 === C3 ? _.colors : C3, F2 = i3.nodeId, X2 = void 0 === F2 ? $.nodeId : F2, Y2 = i3.nodeSize, B2 = void 0 === Y2 ? _.nodeSize : Y2, G = i3.renderNode, H3 = void 0 === G ? _.renderNode : G, T3 = i3.enableGridX, V = void 0 === T3 ? _.enableGridX : T3, O3 = i3.gridXValues, U2 = i3.enableGridY, q3 = void 0 === U2 ? _.enableGridY : U2, Q2 = i3.gridYValues, Z2 = i3.axisTop, ee2 = i3.axisRight, ne2 = i3.axisBottom, oe2 = void 0 === ne2 ? _.axisBottom : ne2, ie2 = i3.axisLeft, te2 = void 0 === ie2 ? _.axisLeft : ie2, re2 = i3.annotations, ae2 = void 0 === re2 ? _.annotations : re2, de2 = i3.isInteractive, se2 = void 0 === de2 ? _.isInteractive : de2, le2 = i3.debugMesh, ue2 = void 0 === le2 ? _.debugMesh : le2, ce2 = i3.onMouseEnter, he2 = i3.onMouseMove, fe2 = i3.onMouseLeave, ve = i3.onClick, me = i3.tooltip, ge = void 0 === me ? _.tooltip : me, pe = i3.legends, ye = void 0 === pe ? _.legends : pe, xe = i3.canvasRef, Me = (0, import_react2.useRef)(null), Se = zt(), be = (0, import_react2.useState)(null), we = be[0], Ie = be[1], ke = wt(m2, x2, M2), ze = ke.margin, Ee = ke.innerWidth, Ce = ke.innerHeight, Le = ke.outerWidth, We = ke.outerHeight, Fe = J2({ data: t3, xScaleSpec: l, xFormat: u, yScaleSpec: f, yFormat: v2, width: Ee, height: Ce, nodeId: X2, nodeSize: B2, colors: W4 }), Xe = Fe.xScale, Ye = Fe.yScale, Be = Fe.nodes, Ge = Fe.legendData, He = K(Be, ae2), Re = W({ points: Be, width: Ee, height: Ce, debug: ue2 }), Te = Re.delaunay, Ve = Re.voronoi, je = (0, import_react2.useMemo)(function() {
    return { xScale: Xe, yScale: Ye, nodes: Be, margin: ze, innerWidth: Ee, innerHeight: Ce, outerWidth: Le, outerHeight: We };
  }, [Xe, Ye, Be, ze, Ee, Ce, Le, We]);
  (0, import_react2.useEffect)(function() {
    if (Me.current) {
      Me.current.width = Le * k3, Me.current.height = We * k3;
      var e3 = Me.current.getContext("2d");
      e3.scale(k3, k3), e3.fillStyle = Se.background, e3.fillRect(0, 0, Le, We), e3.translate(ze.left, ze.top), E2.forEach(function(n3) {
        if ("grid" === n3) e3.lineWidth = Se.grid.line.strokeWidth, e3.strokeStyle = Se.grid.line.stroke, V && z(e3, { width: Ee, height: Ce, scale: Xe, axis: "x", values: O3 }), q3 && z(e3, { width: Ee, height: Ce, scale: Ye, axis: "y", values: Q2 });
        else if ("annotations" === n3) J(e3, { annotations: He, theme: Se });
        else if ("axes" === n3) j(e3, { xScale: Xe, yScale: Ye, width: Ee, height: Ce, top: Z2, right: ee2, bottom: oe2, left: te2, theme: Se });
        else if ("nodes" === n3) Be.forEach(function(n4) {
          H3(e3, n4);
        });
        else if ("mesh" === n3) ue2 && (z2(e3, Ve), we && H2(e3, Ve, we.index));
        else if ("legends" === n3) ye.forEach(function(n4) {
          H(e3, A({}, n4, { data: Ge, containerWidth: Ee, containerHeight: Ce, theme: Se }));
        });
        else {
          if ("function" != typeof n3) throw new Error("Invalid layer: " + n3);
          n3(e3, je);
        }
      });
    }
  }, [Me, Ee, Ce, Le, We, ze.top, ze.left, k3, H3, E2, je, Se, Xe, Ye, Be, V, q3, Z2, ee2, oe2, te2, ye, Ge, ue2, Ve, we, He]);
  var Oe = k(), De = Oe.showTooltipFromEvent, Ne = Oe.hideTooltip, Pe = (0, import_react2.useCallback)(function(e3) {
    var n3 = Sn(Me.current, e3), o3 = n3[0], i4 = n3[1];
    if (!jn(ze.left, ze.top, Ee, Ce, o3, i4)) return null;
    var t4 = Te.find(o3 - ze.left, i4 - ze.top);
    return Be[t4];
  }, [Me, ze, Ee, Ce, Te]), Ae = (0, import_react2.useCallback)(function(e3) {
    var n3 = Pe(e3);
    Ie(n3), n3 ? (De((0, import_react2.createElement)(ge, { node: n3 }), e3), we && we.id !== n3.id && (fe2 && fe2(we, e3), ce2 && ce2(n3, e3)), we || ce2 && ce2(n3, e3), he2 && he2(n3, e3)) : (Ne(), we && fe2 && fe2(we, e3));
  }, [Pe, we, Ie, De, Ne, ge, ce2, he2, fe2]), Ue = (0, import_react2.useCallback)(function(e3) {
    Ne(), Ie(null), we && fe2 && fe2(we, e3);
  }, [Ne, we, Ie, fe2]), qe = (0, import_react2.useCallback)(function(e3) {
    if (ve) {
      var n3 = Pe(e3);
      n3 && ve(n3, e3);
    }
  }, [Pe, ve]);
  return (0, import_jsx_runtime2.jsx)("canvas", { ref: function(e3) {
    Me.current = e3, xe && "current" in xe && (xe.current = e3);
  }, width: Le * k3, height: We * k3, style: { width: Le, height: We, cursor: se2 ? "auto" : "normal" }, onMouseEnter: se2 ? Ae : void 0, onMouseMove: se2 ? Ae : void 0, onMouseLeave: se2 ? Ue : void 0, onClick: se2 ? qe : void 0 });
};
var he = (0, import_react2.forwardRef)(function(e3, n3) {
  var o3 = e3.isInteractive, i3 = e3.renderWrapper, t3 = e3.theme, r2 = U(e3, ue);
  return (0, import_jsx_runtime2.jsx)(St, { isInteractive: o3, renderWrapper: i3, theme: t3, animate: false, children: (0, import_jsx_runtime2.jsx)(ce, A({}, r2, { canvasRef: n3 })) });
});
var fe = (0, import_react2.forwardRef)(function(e3, n3) {
  return (0, import_jsx_runtime2.jsx)(It, { children: function(o3) {
    var i3 = o3.width, t3 = o3.height;
    return (0, import_jsx_runtime2.jsx)(he, A({ width: i3, height: t3 }, e3, { ref: n3 }));
  } });
});
export {
  le as ResponsiveScatterPlot,
  fe as ResponsiveScatterPlotCanvas,
  se as ScatterPlot,
  he as ScatterPlotCanvas,
  _ as canvasDefaultProps,
  Z as commonDefaultProps,
  $ as svgDefaultProps,
  J2 as useScatterPlot,
  K as useScatterPlotAnnotations
};
//# sourceMappingURL=@nivo_scatterplot.js.map
